<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Neon Galaxy Fluid Hero</title>
<style>
  * { margin: 0; padding: 0; }
  body { background: #000; overflow: hidden; }
</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
<script>
// --- PIXI setup ---
let app = new PIXI.Application({ resizeTo: window, backgroundAlpha: 0 });
document.body.appendChild(app.view);

let particles = [];
let particleCount = 150;
let connectionDistance = 120;

// --- Helper: random shape ---
function makeShape(size, color) {
    let g = new PIXI.Graphics();
    g.beginFill(color);

    let shapeType = Math.floor(Math.random() * 3); // 0=circle,1=square,2=triangle
    if (shapeType === 0) {
        g.drawCircle(0, 0, size);
    } else if (shapeType === 1) {
        g.drawRect(-size, -size, size*2, size*2);
    } else {
        g.moveTo(0, -size);
        g.lineTo(size, size);
        g.lineTo(-size, size);
        g.lineTo(0, -size);
    }
    g.endFill();
    return app.renderer.generateTexture(g);
}

// --- Particle factory ---
function createParticle(color) {
    let size = Math.random() * 3 + 2;
    let texture = makeShape(size, color);
    let sprite = new PIXI.Sprite(texture);

    sprite.x = Math.random() * app.screen.width;
    sprite.y = Math.random() * app.screen.height;

    sprite.speed = 0.015 + Math.random() * 0.035;
    sprite.offset = Math.random() * 1000;
    sprite.radius = 40 + Math.random() * 150; // base orbit radius
    sprite.angle = Math.random() * Math.PI * 2;
    sprite.depth = Math.random(); // parallax depth

    sprite.tint = color;
    sprite.alpha = 0.4 + (1 - sprite.depth) * 0.6; // fade with depth
    return sprite;
}

let baseColors = [0xff66cc, 0x66ccff, 0xffff66, 0x66ff99, 0xff9966];

for (let i = 0; i < particleCount; i++) {
    let color = baseColors[Math.floor(Math.random() * baseColors.length)];
    let p = createParticle(color);
    particles.push(p);
    app.stage.addChild(p);
}

let mouse = { x: app.screen.width / 2, y: app.screen.height / 2 };
window.addEventListener("mousemove", e => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
});

let lineGraphics = new PIXI.Graphics();
app.stage.addChild(lineGraphics);

// --- Noise function ---
function noise(t) {
    return Math.sin(t * 0.7) * 0.5 + Math.sin(t * 1.3) * 0.5;
}

// --- Animation loop ---
app.ticker.add((delta) => {
    lineGraphics.clear();

    particles.forEach((p, i) => {
        let time = app.ticker.lastTime / 5000;

        // Breathing radius via noise
        let dynamicRadius = p.radius + noise(time + p.offset) * 20;

        // Orbit motion
        p.angle += (0.01 + Math.random() * 0.002) * (1 - p.depth);
        let targetX = mouse.x + Math.cos(p.angle + p.offset) * dynamicRadius;
        let targetY = mouse.y + Math.sin(p.angle + p.offset) * dynamicRadius;

        // Smooth follow
        p.x += (targetX - p.x) * p.speed;
        p.y += (targetY - p.y) * p.speed;

        // Glow pulse
        let scalePulse = 1 + Math.sin((app.ticker.lastTime + p.offset) / 500) * 0.2;
        p.scale.set(scalePulse * (1 - p.depth * 0.3));

        // Color shift over time
        let hueShift = (Math.sin(time + p.offset) * 30) | 0;
        p.tint = shiftHue(baseColors[i % baseColors.length], hueShift);

        // Connect lines between nearby particles
        for (let j = i + 1; j < particles.length; j++) {
            let p2 = particles[j];
            let dist = Math.hypot(p.x - p2.x, p.y - p2.y);
            if (dist < connectionDistance) {
                let alpha = 1 - dist / connectionDistance;
                lineGraphics.lineStyle(1, p.tint, alpha * 0.5);
                lineGraphics.moveTo(p.x, p.y);
                lineGraphics.lineTo(p2.x, p2.y);
            }
        }
    });
});

// --- Hue shifting helper ---
function shiftHue(color, degree) {
    let rgb = PIXI.utils.hex2rgb(color);
    let hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);
    hsl[0] = (hsl[0] + degree / 360) % 1;
    let newRgb = hslToRgb(hsl[0], hsl[1], hsl[2]);
    return PIXI.utils.rgb2hex(newRgb);
}

function rgbToHsl(r, g, b) {
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if(max === min) { h = s = 0; }
    else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return [h, s, l];
}

function hslToRgb(h, s, l) {
    let r, g, b;
    if(s === 0) {
        r = g = b = l;
    } else {
        let hue2rgb = (p, q, t) => {
            if(t < 0) t += 1;
            if(t > 1) t -= 1;
            if(t < 1/6) return p + (q - p) * 6 * t;
            if(t < 1/2) return q;
            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        };
        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }
    return [r, g, b];
}
</script>
</body>
</html>
